CSE 214

Online on Creational Pattern
Time: 30 minutes

You are developing a document editor that supports 3 types of file formats: .docx, .pdf,
and .txt. To handle each file type, you need different document processors. All
document processors implement an interface called DocumentProcessor, which
contains two methods - LoadDocument and SaveDocument (For now, these may just
print a message).
Given a file name, your system has to recognize the file type and use the appropriate
document processor to load and save a file. The output will be two messages showing
that the file was loaded and saved.

This problem is a perfect candidate for the **Factory Pattern** (specifically the **Simple Factory** idiom).

You need a central place (the Factory) to decide *which* specific processor to create based on the file extension. The client (the editor) shouldn't care about the specific logic of matching `.pdf` to `PdfProcessor`; it just wants a processor that works.

Here is the complete solution:

### 1. The Interface (Product)

Defines the common behavior for all processors.

```java
public interface DocumentProcessor {
    void loadDocument(String fileName);
    void saveDocument(String fileName);
}

```

### 2. Concrete Classes

These handle the specific logic for each file type.

```java
// Processor for .docx
public class DocxProcessor implements DocumentProcessor {
    @Override
    public void loadDocument(String fileName) {
        System.out.println("Loading Word document: " + fileName);
    }

    @Override
    public void saveDocument(String fileName) {
        System.out.println("Saving Word document: " + fileName);
    }
}

// Processor for .pdf
public class PdfProcessor implements DocumentProcessor {
    @Override
    public void loadDocument(String fileName) {
        System.out.println("Loading PDF document: " + fileName);
    }

    @Override
    public void saveDocument(String fileName) {
        System.out.println("Saving PDF document: " + fileName);
    }
}

// Processor for .txt
public class TxtProcessor implements DocumentProcessor {
    @Override
    public void loadDocument(String fileName) {
        System.out.println("Loading Text document: " + fileName);
    }

    @Override
    public void saveDocument(String fileName) {
        System.out.println("Saving Text document: " + fileName);
    }
}

```

### 3. The Factory

This class contains the logic to inspect the file name and return the correct processor.

```java
public class DocumentProcessorFactory {
    
    public static DocumentProcessor getProcessor(String fileName) {
        if (fileName == null) {
            throw new IllegalArgumentException("File name cannot be null");
        }
        
        String lowerCaseName = fileName.toLowerCase();
        
        if (lowerCaseName.endsWith(".docx")) {
            return new DocxProcessor();
        } else if (lowerCaseName.endsWith(".pdf")) {
            return new PdfProcessor();
        } else if (lowerCaseName.endsWith(".txt")) {
            return new TxtProcessor();
        } else {
            throw new IllegalArgumentException("Unsupported file format: " + fileName);
        }
    }
}

```

### 4. Client Code (Main)

The main program simply asks the factory for a processor and uses it.

```java
public class DocumentEditor {
    public static void main(String[] args) {
        // Test Case 1: PDF
        String file1 = "assignment.pdf";
        processFile(file1);

        System.out.println("-----------------");

        // Test Case 2: DOCX
        String file2 = "resume.docx";
        processFile(file2);

        System.out.println("-----------------");

        // Test Case 3: TXT
        String file3 = "notes.txt";
        processFile(file3);
    }

    // Helper method to simulate the editor logic
    private static void processFile(String fileName) {
        try {
            // 1. Ask Factory for the correct processor
            DocumentProcessor processor = DocumentProcessorFactory.getProcessor(fileName);
            
            // 2. Use the processor (Polymorphism)
            processor.loadDocument(fileName);
            processor.saveDocument(fileName);
            
        } catch (IllegalArgumentException e) {
            System.out.println("Error: " + e.getMessage());
        }
    }
}

```

A2: CSE 214
Online on Creational Pattern
Time: 25 minutes

You are designing a system to manage two computer models: WorkPro and LiteMax. They have
differences in their Processor and Display. WorkPro is a professional computer uses a Intel
Xeon Processor and IPS display. LiteMax is more of a lightweight device that uses ARM
Processor and OLED display. There are two different companies, one of which only produces
Processors and the other only produces display.
You have to implement the system where the user will select their preferred model. The system
will create the computer with proper processor and display. The classes that represent the
computers will contain functions to print the descriptions with model names, components and
other characteristics.

This problem requires the **Abstract Factory Pattern**.

**Why?**
The key requirement is that you have two distinct "families" of products:

1. **WorkPro Family**: Intel Xeon + IPS
2. **LiteMax Family**: ARM + OLED

The Abstract Factory pattern ensures that a system (the Computer) uses the correct matching parts (Xeon with IPS) without the client code needing to know specific class names.

Here is the complete solution:

### 1. Abstract Products (The Parts)

First, define the interfaces for the components.

```java
// Interface for all Processors
interface Processor {
    void showSpecs();
}

// Interface for all Displays
interface Display {
    void showSpecs();
}

```

### 2. Concrete Products (The Specific Parts)

Implement the specific hardware for each model.

```java
// Parts for WorkPro
class IntelXeonProcessor implements Processor {
    @Override
    public void showSpecs() {
        System.out.println(" - Processor: Intel Xeon (Professional Grade)");
    }
}

class IPSDisplay implements Display {
    @Override
    public void showSpecs() {
        System.out.println(" - Display:   IPS Panel (Color Accurate)");
    }
}

// Parts for LiteMax
class ARMProcessor implements Processor {
    @Override
    public void showSpecs() {
        System.out.println(" - Processor: ARM Chip (Power Efficient)");
    }
}

class OLEDDisplay implements Display {
    @Override
    public void showSpecs() {
        System.out.println(" - Display:   OLED Panel (Vibrant Colors)");
    }
}

```

### 3. Abstract Factory

This interface defines what a "Computer Factory" must be able to produce.

```java
public interface ComputerFactory {
    Processor createProcessor();
    Display createDisplay();
}

```

### 4. Concrete Factories

These factories group the correct parts together. This ensures a WorkPro always gets a Xeon and an IPS.

```java
// Factory for WorkPro parts
class WorkProFactory implements ComputerFactory {
    @Override
    public Processor createProcessor() {
        return new IntelXeonProcessor();
    }

    @Override
    public Display createDisplay() {
        return new IPSDisplay();
    }
}

// Factory for LiteMax parts
class LiteMaxFactory implements ComputerFactory {
    @Override
    public Processor createProcessor() {
        return new ARMProcessor();
    }

    @Override
    public Display createDisplay() {
        return new OLEDDisplay();
    }
}

```

### 5. Client Class (The Computer)

This class represents the final product. It takes a factory to assemble itself.

```java
class Computer {
    private String modelName;
    private Processor processor;
    private Display display;

    // The Computer is assembled using the factory provided
    public Computer(String modelName, ComputerFactory factory) {
        this.modelName = modelName;
        this.processor = factory.createProcessor();
        this.display = factory.createDisplay();
    }

    public void printDescription() {
        System.out.println("---------------------------------");
        System.out.println("Model: " + modelName);
        System.out.println("Specifications:");
        processor.showSpecs();
        display.showSpecs();
        System.out.println("---------------------------------");
    }
}

```

### 6. Main Method

Simulating the user selection.

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        ComputerFactory factory;
        Computer myComputer;

        System.out.println("Choose your preferred model:");
        System.out.println("1. WorkPro (Professional)");
        System.out.println("2. LiteMax (Lightweight)");
        int choice = scanner.nextInt();

        if (choice == 1) {
            // User chose WorkPro -> Use the WorkPro Factory
            factory = new WorkProFactory();
            myComputer = new Computer("WorkPro", factory);
        } else {
            // User chose LiteMax (or default) -> Use the LiteMax Factory
            factory = new LiteMaxFactory();
            myComputer = new Computer("LiteMax", factory);
        }

        System.out.println("\nSystem creating computer...");
        myComputer.printDescription();
    }
}

```

